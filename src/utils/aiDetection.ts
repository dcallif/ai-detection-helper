import { AnalysisResults } from '../types/analysis';

export const analyzeContent = (text: string): AnalysisResults => {
  const normalizedText = text.trim().replace(/\s+/g, ' ');
  
  if (!normalizedText || normalizedText.length < 50) {
    return createBasicResults(30, "Text sample is too short for reliable analysis.");
  }

  // Quick check for explicit AI disclosure
  const hasExplicitAIDisclosure = /\b(written by an? AI|generated by an? AI|AI-generated|language model generated|GPT-3 wrote|artificial intelligence wrote)\b/i.test(normalizedText);
  
  if (hasExplicitAIDisclosure) {
    return createExplicitAIResults();
  }
  
  const indicators = calculateIndicators(normalizedText);
  const aiProbability = calculateOverallProbability(indicators);
  const summary = generateSummary(aiProbability, indicators);
  
  return {
    aiProbability,
    summary,
    indicators
  };
};

const calculateIndicators = (text: string) => {
  return [
    {
      name: "Pattern Recognition",
      value: calculatePatternScore(text),
      description: "Analyzes repetitive structures and formulaic writing patterns."
    },
    {
      name: "Descriptive Density",
      value: calculateDescriptiveDensityScore(text),
      description: "Measures the concentration of descriptive elements and adjectives."
    },
    {
      name: "Structural Consistency",
      value: calculateStructuralConsistencyScore(text),
      description: "Evaluates the uniformity of writing structure and flow."
    },
    {
      name: "Natural Variation",
      value: calculateNaturalVariationScore(text),
      description: "Measures organic variability in expression and structure."
    },
    {
      name: "Scene Construction",
      value: calculateSceneConstructionScore(text),
      description: "Analyzes the methodical building of scenes and descriptions."
    }
  ];
};

const calculatePatternScore = (text: string): number => {
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  let score = 0;
  
  // Check for parallel structure patterns (increased sensitivity)
  const parallelStructures = sentences.filter(s => 
    /^[A-Z][^,]+(,\s[a-z][^,]+){2,}/.test(s)
  ).length;
  score += (parallelStructures / sentences.length) * 80; // Increased from 60

  // Analyze sentence openings (increased weight)
  const openings = sentences.map(s => s.split(/\s+/).slice(0, 2).join(' '));
  const uniqueOpenings = new Set(openings).size;
  score += ((sentences.length - uniqueOpenings) / sentences.length) * 60; // Increased from 40

  // Check for methodical description patterns (increased sensitivity)
  const descriptivePatterns = sentences.filter(s =>
    /\b(was|were)\b.*\b(with|by|in|at|on)\b/.test(s)
  ).length;
  score += (descriptivePatterns / sentences.length) * 70; // Increased from 50

  return Math.min(100, Math.max(0, score));
};

const calculateDescriptiveDensityScore = (text: string): number => {
  const words = text.toLowerCase().split(/\s+/);
  let score = 0;

  // Count descriptive adjectives and adverbs (expanded list and increased weight)
  const descriptors = words.filter(w => 
    /^(bright|calm|crisp|distant|early|faint|gentle|muted|narrow|old|quick|sharp|simple|soft|wooden|clear|fresh|warm|cool|subtle|vivid|peaceful|quiet|busy|serene)/.test(w)
  ).length;
  score += (descriptors / words.length) * 200; // Increased from 150

  // Check for sensory details (increased weight)
  const sensoryWords = /(smell|scent|aroma|sight|sound|echo|feel|touch|taste|fragrance|texture|sensation|vibration)/gi;
  const sensoryCount = (text.match(sensoryWords) || []).length;
  score += sensoryCount * 20; // Increased from 15

  // Analyze descriptive phrases (increased weight)
  const descriptivePhrases = text.match(/[a-z]+-[a-z]+/g) || [];
  score += descriptivePhrases.length * 15; // Increased from 10

  return Math.min(100, Math.max(0, score));
};

const calculateStructuralConsistencyScore = (text: string): number => {
  const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 0);
  let score = 0;

  // Check paragraph length consistency (increased sensitivity)
  const paragraphLengths = paragraphs.map(p => p.split(/\s+/).length);
  const avgLength = paragraphLengths.reduce((a, b) => a + b, 0) / paragraphLengths.length;
  const lengthVariance = paragraphLengths.reduce((sum, len) => 
    sum + Math.abs(len - avgLength), 0) / paragraphLengths.length;
  score += (1 - (lengthVariance / avgLength)) * 70; // Increased from 50

  // Analyze scene transitions (increased weight)
  const transitions = paragraphs.filter(p => 
    /^(Later|By|In|At|The|She|He|They|As|When|While)/.test(p)
  ).length;
  score += (transitions / paragraphs.length) * 70; // Increased from 50

  // Check for consistent time progression (increased sensitivity)
  const timeMarkers = /(morning|afternoon|evening|later|then|after|before|during|while|moment|instant|suddenly)/gi;
  const timeProgression = (text.match(timeMarkers) || []).length;
  score += Math.min(70, timeProgression * 15); // Increased from 50 and 10

  return Math.min(100, Math.max(0, score));
};

const calculateNaturalVariationScore = (text: string): number => {
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  let score = 100;

  // Check for overly balanced sentence structures (increased penalty)
  const structureBalance = sentences.filter(s => 
    s.includes(',') && s.split(',').length === 2
  ).length;
  score -= (structureBalance / sentences.length) * 40; // Increased from 30

  // Analyze adjective placement variety (increased penalty)
  const standardAdjOrder = sentences.filter(s =>
    /\b(the|a|an)\s+[a-z]+\s+[a-z]+\b/.test(s)
  ).length;
  score -= (standardAdjOrder / sentences.length) * 30; // Increased from 20

  // Check for natural interruptions and asides (reduced bonus)
  const naturalBreaks = sentences.filter(s => 
    /[-â€”()]/.test(s)
  ).length;
  score += (naturalBreaks / sentences.length) * 15; // Decreased from 20

  return Math.min(100, Math.max(0, score));
};

const calculateSceneConstructionScore = (text: string): number => {
  let score = 0;

  // Check for methodical scene building (increased weights)
  const sceneElements = {
    visualDetails: /(looked|appeared|saw|watched|observed|noticed|gazed|glimpsed|viewed|spotted)/gi,
    soundDetails: /(heard|sounded|echoed|rang|rumbled|whispered|murmured|rustled|hummed)/gi,
    atmosphericDetails: /(air|sky|light|shadow|weather|temperature|atmosphere|climate|breeze|mist)/gi,
    locationMarkers: /(beside|between|across|through|along|around|near|beyond|within|amidst)/gi
  };

  Object.values(sceneElements).forEach(pattern => {
    const matches = text.match(pattern) || [];
    score += matches.length * 20; // Increased from 15
  });

  // Analyze descriptive sequences (increased weight)
  const sequentialDesc = text.match(/\b(first|then|next|finally|lastly|subsequently|eventually|gradually)\b/gi) || [];
  score += sequentialDesc.length * 15; // Increased from 10

  // Check for balanced environmental details (increased weight)
  const environmentalDetails = /\b(grass|trees|buildings|street|sky|sun|clouds|path|road|garden|park)\b/gi;
  const envCount = (text.match(environmentalDetails) || []).length;
  score += Math.min(70, envCount * 8); // Increased from 50 and 5

  return Math.min(100, Math.max(0, score));
};

const calculateOverallProbability = (indicators: any[]): number => {
  // Adjusted weights to increase sensitivity
  const weights = {
    "Pattern Recognition": 0.30, // Increased from 0.25
    "Descriptive Density": 0.25,
    "Structural Consistency": 0.20,
    "Natural Variation": 0.10, // Decreased from 0.15
    "Scene Construction": 0.15
  };
  
  let weightedSum = 0;
  let totalWeight = 0;
  
  indicators.forEach(indicator => {
    const weight = weights[indicator.name as keyof typeof weights] || 0;
    weightedSum += indicator.value * weight;
    totalWeight += weight;
  });
  
  // Apply a slight boost to the final score
  const baseScore = totalWeight > 0 ? weightedSum / totalWeight : 50;
  return Math.round(Math.min(100, baseScore * 1.2)); // 20% boost to final score
};

const generateSummary = (probability: number, indicators: any[]): string => {
  if (probability > 80) {
    return "This content strongly indicates AI generation, showing systematic scene construction and highly structured descriptive patterns.";
  } else if (probability > 60) {
    return "This content appears to be AI-generated, with methodical description patterns and consistent structural elements.";
  } else if (probability > 40) {
    return "This content shows mixed signals that could indicate either AI assistance or formal human writing.";
  } else if (probability > 20) {
    return "This content likely represents human writing, displaying natural variation and organic descriptive flow.";
  } else {
    return "This content strongly indicates human authorship, with spontaneous style and natural language patterns.";
  }
};

const createBasicResults = (probability: number, message: string): AnalysisResults => {
  return {
    aiProbability: probability,
    summary: message,
    indicators: [
      {
        name: "Sample Size",
        value: 0,
        description: "Text is too short for detailed analysis."
      }
    ]
  };
};

const createExplicitAIResults = (): AnalysisResults => {
  return {
    aiProbability: 95,
    summary: "This content explicitly states it was written by AI, and analysis confirms strong AI-generated patterns.",
    indicators: [
      {
        name: "AI Disclosure",
        value: 100,
        description: "Content explicitly states it was created by AI."
      },
      {
        name: "Pattern Recognition",
        value: 90,
        description: "Shows characteristic AI writing patterns."
      },
      {
        name: "Descriptive Density",
        value: 95,
        description: "Contains highly structured descriptive elements."
      }
    ]
  };
};